---
title: "Data cleaning"
author: "Devinn Chi and Chris Lohmeier"
date: "2024-02-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, warning = FALSE, message = FALSE}
library(tidyverse)
library(dplyr)
library(readr)
library(jsonlite)
library(skimr)
library(lubridate)
library(ggpubr)
library(cowplot)
library(broom)
library(gtools)
library(corrplot)
```

```{r}
# Code to convert json to CSV

# steam <- fromJSON("..\\data\\data_raw\\steam.jsonmdb", simplifyDataFrame = TRUE)
# 
# write.csv(steam, "..\\data\\data_clean\\steam.jsonmdb")
```


# Reading in Data
```{r}
steamData <- read_csv("../data/data_clean/steam.csv")
```
# Overview of data
```{r}
skim(steamData)
steamData %>% pull(platforms) %>% unique()
```
> Findings:
1. Games limited to PC, Mac, and Linux
2. Nearly 34,000 different developers!
3. Data mostly complete aside from ratings - it would be good to see if this means that it is biased in any way

# cleaning data
```{r}
steamDataClean <- steamData %>% 
  select(-store_url, -store_promo_url, -...1, -image, -voiceovers, -achievements, -gfq_url, -gfq_difficulty_comment, -gfq_rating_comment, -gfq_length_comment, -stsp_owners, -stsp_mdntime, -hltb_url, -hltb_single, -hltb_complete, -meta_url, -igdb_url, -igdb_single, -igdb_complete, -published_meta, -published_hltb, -published_stsp, -published_igdb) %>% 
  mutate(
    full_price = full_price/100,
    discount = discount/100,
    current_price = current_price/100) %>% 
    filter(full_price <= 200) %>%  # Only 2 games with full_price > 199.99
  mutate(gfq_rating = gfq_rating*20) # scales gfq_rating to be on the 0-100 scale
```

# write this data to csv
```{r}
# write.csv(steamDataClean, file = "../data/data_clean/steamDataClean.csv", row.names = FALSE)
```


# Wider dataset
```{r}
steamDataGenres <- steamDataClean %>% 
  mutate(genres = str_split(genres, ",")) %>% 
  unnest() %>% 
  pivot_wider(names_from = genres, values_from = genres)

# steamDataTags <- steamDataClean %>% 
#   mutate(tags = str_split(tags, ",")) %>% 
#   unnest() %>% 
#   pivot_wider(names_from = tags, values_from = tags)
# 
# steamDataCategories <- steamDataClean %>% 
#   mutate(categories = str_split(categories, ",")) %>% 
#   unnest() %>% 
#   pivot_wider(names_from = categories, values_from = categories)

# Does not work :(
# genres <- names(steamDataWide)[23:39]
# for(n in genres) {
#   steamDataWide <- steamDataWide %>% 
#     mutate(genres[n] <-  !is.na(genres[n]))
# } 
  
```

# wider data csv
```{r}
# write.csv(steamDataGenres, file = "../data/data_clean/steamDataGenres.csv", row.names = FALSE)
```

# Data Exploration
```{r}
# Code for getting developer size
steamDataDevelopers <- steamDataClean %>% 
  group_by(developers) %>% 
  mutate(developer_size = n())

# This may not be a good measure for how well-reasourced a developer is - maybe sales data exists somewhere?
steamDataDevelopers %>% 
  group_by(developers) %>% 
  summarize(developer_size = n()) %>% 
  arrange(desc(developer_size))

ggplot(steamDataDevelopers) +
  geom_histogram(aes(x = developer_size))

ggplot(steamDataDevelopers) +
  geom_point(aes(x = developer_size, y = full_price)) +
  geom_smooth(aes(x = developer_size, y = full_price), method = "lm", se = FALSE) +
  theme_classic() +
  labs(y = "Price", x = "Developer Size")
```

# Density plot of prices
```{r}
steamDataClean %>% 
ggplot() +
  geom_density(aes(x = full_price)) +
  theme_classic()
```



# Devinn's Chunk
```{r, fig.width = 15}
customTheme <- theme_minimal() +
  theme(
    text = element_text(size = 12),
    plot.title = element_text(face = "bold", size = 12),
    axis.title = element_text(face = "bold"),
    legend.position = "bottom"
  )

makPtoGPlot <- function(xlab, ylab, titl, genreVar, popularityVar, data) {
  cleanData <- data %>% 
    select(full_price, !!sym(genreVar), !!sym(popularityVar)) %>%
    filter(!is.na(!!sym(genreVar)), full_price <= 70, !!sym(popularityVar) <= 250)
  
  ggplot(cleanData) + 
  geom_point(aes(x = full_price, y = !!sym(popularityVar))) +
  stat_smooth(aes(x = full_price, y = !!sym(popularityVar)), method = "lm", se = TRUE) +
  labs(title = titl, x = xlab, y = ylab) + 
  customTheme
}



# IGDB popularity
adv_plot <- makPtoGPlot("Price", "Popularity", "Adventure", "Adventure", "igdb_uscore", steamDataGenres)
cas_plot <- makPtoGPlot("Price", "Popularity", "Casual", "Casual", "igdb_uscore", steamDataGenres)
act_plot <- makPtoGPlot("Price", "Popularity", "Action", "Action", "igdb_uscore", steamDataGenres)
rac_plot <- makPtoGPlot("Price", "Popularity", "Racing", "Racing",  "igdb_uscore",steamDataGenres)
ind_plot <- makPtoGPlot("Price", "Popularity", "Indie", "Indie",  "igdb_uscore",steamDataGenres)
RPG_plot <- makPtoGPlot("Price", "Popularity", "RPG", "RPG",  "igdb_uscore",steamDataGenres)
sim_plot <- makPtoGPlot("Price", "Popularity", "Simulation", "Simulation", "igdb_uscore", steamDataGenres)

IGDBplot <- ggarrange(adv_plot, cas_plot, act_plot, rac_plot, ind_plot, RPG_plot, sim_plot, 
          ncol = 3, nrow = 3, common.legend = TRUE) 

plot_title <- ggdraw() +
  draw_label("Price to Popularity by Genre (IGDB)", fontface = 'bold', size = 14)

ggarrange(plot_title, IGDBplot, nrow = 2, rel_heights = c(0.1, 0.9), heights = c(0.1, 0.9))



# Steam UScore 
adv_plotS <- makPtoGPlot("Price", "Popularity", "Adventure", "Adventure", "store_uscore", steamDataGenres)
cas_plotS <- makPtoGPlot("Price", "Popularity", "Casual", "Casual", "store_uscore", steamDataGenres)
act_plotS <- makPtoGPlot("Price", "Popularity", "Action", "Action", "store_uscore", steamDataGenres)
rac_plotS <- makPtoGPlot("Price", "Popularity", "Racing", "Racing",  "store_uscore",steamDataGenres)
ind_plotS <- makPtoGPlot("Price", "Popularity", "Indie", "Indie",  "store_uscore",steamDataGenres)
RPG_plotS <- makPtoGPlot("Price", "Popularity", "RPG", "RPG",  "store_uscore",steamDataGenres)
sim_plotS <- makPtoGPlot("Price", "Popularity", "Simulation", "Simulation", "store_uscore", steamDataGenres)

steamPlot <- ggarrange(adv_plotS, cas_plotS, act_plotS, rac_plotS, ind_plotS, RPG_plotS, sim_plotS, 
          ncol = 3, nrow = 3, common.legend = TRUE)

plot_titles <- ggdraw() +
  draw_label("Price to Popularity by Genre (Steam User Score)", fontface = 'bold', size = 14)

ggarrange(plot_titles, steamPlot, nrow = 2, rel_heights = c(0.1, 0.9), heights = c(0.1, 0.9))



# Metacritic User Score
adv_plotM <- makPtoGPlot("Price", "Popularity", "Adventure", "Adventure", "meta_uscore", steamDataGenres)
cas_plotM <- makPtoGPlot("Price", "Popularity", "Casual", "Casual", "meta_uscore", steamDataGenres)
act_plotM <- makPtoGPlot("Price", "Popularity", "Action", "Action", "meta_uscore", steamDataGenres)
rac_plotM <- makPtoGPlot("Price", "Popularity", "Racing", "Racing",  "meta_uscore",steamDataGenres)
ind_plotM <- makPtoGPlot("Price", "Popularity", "Indie", "Indie",  "meta_uscore",steamDataGenres)
RPG_plotM <- makPtoGPlot("Price", "Popularity", "RPG", "RPG",  "meta_uscore",steamDataGenres)
sim_plotM <- makPtoGPlot("Price", "Popularity", "Simulation", "Simulation", "meta_uscore", steamDataGenres)

MetacriticPlot <- ggarrange(adv_plotM, cas_plotM, act_plotM, rac_plotM, ind_plotM, RPG_plotM, sim_plotM, 
          ncol = 3, nrow = 3, common.legend = TRUE)

plot_titlem <- ggdraw() +
  draw_label("Price to Popularity by Genre (MetaCritic User Score)", fontface = 'bold', size = 14)

ggarrange(plot_titlem, MetacriticPlot, nrow = 2, rel_heights = c(0.1, 0.9), heights = c(0.1, 0.9))
```



# Chris's Chunk
```{r}
ggplot(steamDataClean) + 
  geom_boxplot(aes(x = platforms, y = full_price)) + 
  scale_y_continuous(limits = c(0, 50))

steamDataClean %>%  
  mutate(published_store = ymd(published_store)) %>%
  mutate(year = year(published_store)) %>% 
  ggplot() +
    geom_boxplot(aes(x = year, y = full_price, group = year))


# Code for getting developer size
steamDataDevelopers <- steamDataClean %>% 
  group_by(developers) %>% 
  mutate(developer_size = n()) %>% 
  ungroup() %>% 
  mutate(size_cat = cut(developer_size, breaks = 2))

steamDataDevelopers %>% 
  group_by(size_cat) %>% 
  summarize(mean = mean(full_price)) %>% 
ggplot() +
  geom_bar(aes(y = mean, x = size_cat), stat = "identity")
```

# Price to year
```{r}
avg_price <- steamDataClean %>%  
  mutate(published_store = ymd(published_store)) %>%
  mutate(year = year(published_store)) %>% 
  group_by(year) %>% 
  summarize(avg_price = mean(full_price))

ggplot(avg_price) +
  geom_bar(aes(x = year, y = avg_price), stat = "identity") +
  #geom_histogram(aes(x = year)) +
  theme_classic()

# Possibly overlay histogram for year?
```


# steam data developers csv
```{r}
# write.csv(steamDataDevelopers, file = "../data/data_clean/steamDataDevelopers.csv", row.names = FALSE)
```


# Correlation visualization (Chris)
```{r}
genre_stats <- function(metric, source, genre) {
  data <- steamDataGenres %>%
    filter(genre == genre) %>%
    drop_na(any_of(c(genre, source, metric))) %>% 
    select(any_of(c(source, metric)))
  
  mod <- lm(as.formula(str_c(metric, " ~ ", source)), data)
  
  stats <- list(
    genre = genre,
    source = source,
    coef = coef(mod)[2],
    max = confint(mod)[source, "97.5 %"],
    min = confint(mod)[source, "2.5 %"],
    cor = cor(data)[source, metric]
  )
  
  return(stats)
}

# Test case
genre_stats("full_price", "igdb_score", "Action")

genres <- c("Action", "Adventure", "Casual", "Racing", "Indie", "RPG", "Simulation")
sources <- c("igdb_uscore", "meta_uscore", "store_uscore")
inputs <- expand_grid(genres, sources)

pop_price_genre <- map2(inputs$sources, inputs$genres, genre_stats, metric = "full_price") %>% 
  bind_rows()

# Determines the order of genres based on average cor
pop_price_genre %>% 
  group_by(genre) %>% 
  summarize(avg = mean(cor)) %>% 
  arrange(avg)

# Coefficients
pop_price_genre %>% 
  mutate(genre = factor(genre, levels = c("Racing", "Adventure", "Casual", "Indie", "RPG", "Action", "Simulation"))) %>% 
  ggplot() +
    geom_bar(aes(x = genre, y = cor, fill = source, color = source), position = "dodge", alpha = 0.5, stat = "identity") +
  theme_classic()

# Correlations
pop_price_genre %>% 
  mutate(genre = factor(genre, levels = c("Racing", "Adventure", "Casual", "Indie", "RPG", "Action", "Simulation"))) %>% 
  ggplot() +
    geom_bar(aes(x = genre, y = coef, fill = source, color = source), position = "dodge", alpha = 0.5, stat = "identity") +
    geom_errorbar(aes(x = genre, ymin = min, ymax = max, color = source), position = "dodge") +
    theme_classic()
```

# Correlation of different rating sites
```{r}
source_stats <- function(source1, source2) {
  data <- steamDataGenres %>% 
    select(any_of(c(source1, source2))) %>% 
    drop_na(any_of(c(source1, source2)))
  
  mod <- lm(as.formula(str_c(source1, " ~ ", source2)), data)
  
  stats <- list(
    source1 = source1,
    source2 = source2,
    coef = coef(mod)[2],
    max = confint(mod)[source2, "97.5 %"],
    min = confint(mod)[source2, "2.5 %"],
    cor = cor(data)[source2, source1]
  )
  
  return(stats)
}

sources2 <- c("igdb_uscore", "meta_uscore", "store_uscore", "grnk_score")
inputs2 <- combn(sources2, 2) %>% 
  t() %>% 
  as.data.frame()

source_cor <- map2(inputs2$V1, inputs2$V2, source_stats) %>% 
  bind_rows() %>% 
  filter(cor == unique(cor)) %>% 
  mutate(sources = str_c(source1, ", ", source2))

# Correlations
source_cor %>% 
  ggplot() +
    geom_bar(aes(x = sources,  y = coef, fill = sources, color = sources), position = "dodge", alpha = 0.5, stat = "identity") +
    geom_errorbar(aes(x = sources, ymin = min, ymax = max, color = sources), position = "dodge") +
    theme_classic()

correlations <- steamDataGenres %>% 
  select("igdb_score", "meta_score", "igdb_uscore", "meta_uscore", "store_uscore", "gfq_rating") %>% 
  drop_na() %>% 
  cor()

corrplot(correlations, method = "number", order = "hclust")
```

# Correlation matrix
```{r}
# Limitation: drop a LOT of NAs
correlations <- steamDataGenres %>% 
  select("igdb_score", "meta_score", "igdb_uscore", "meta_uscore", "store_uscore", "gfq_rating") %>% 
  drop_na() %>% 
  cor()

corrplot(correlations, method = "number", order = "hclust")
```



# Score averages
```{r}
score_avg <- steamDataGenres %>%
  pivot_longer(cols = c(meta_score, meta_uscore, igdb_score, igdb_uscore), names_to = "score_name") %>% 
  group_by(score_name) %>% 
  summarize(avg = mean(value, na.rm = TRUE)) %>% 
  mutate(score_type = ifelse(str_detect(score_name, "uscore"), "not_user_rating", "user_rating")) %>% 
  mutate(source = ifelse(str_detect(score_name, "igdb"), "igdb", "metacritic"))

ggplot(score_avg) +
  geom_bar(aes(x = score_name, y = avg, fill = score_type), color = "#010203", stat = "identity") +
  facet_wrap(~source, scales = "free_x") +
  theme_classic() +
  scale_fill_manual(values = c("#325974", "#4F6B1D"))
```

# IGDB popularity
```{r}
steamDataClean %>% 
  filter(igdb_popularity > 10) %>% 
  ggplot() +
    geom_density(aes(x = igdb_popularity))

steamDataClean %>% 
  filter(igdb_popularity < 100) %>% 
  ggplot() +
    geom_point(aes(x = igdb_popularity, y = igdb_score))

steamDataClean %>% 
  mutate(popularity_cat = cut(igdb_popularity, breaks = seq(0, 50, 10))) %>% 
  ggplot() +
    geom_boxplot(aes(x = popularity_cat, y = igdb_score))

lm(igdb_popularity ~ igdb_score, data = steamDataClean) %>% 
  summary()

popular_games <- steamDataClean %>% 
  filter(igdb_popularity > 10)
```

> https://steamdb.info/charts/
> Steam charts doesn't match igdb popularity well at all

# Final Plots
```{r}
# Distribution of prices
# Price to year
# Big picture price to popularity correlations 
# Correlation matrices
# Score averages
```





```{r}
sessionInfo()
```

